rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper function to check if user is authenticated
    function isSignedIn() {
      return request.auth != null;
    }

    // Helper function to check if user owns the document
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    // Helper function to check if user is member of a couple
    function isCoupleMember(coupleId) {
      let coupleData = get(/databases/$(database)/documents/couples/$(coupleId)).data;
      return coupleData.user1Id == request.auth.uid ||
             coupleData.user2Id == request.auth.uid;
    }

    // Users collection - users can read all, but update rules are relaxed for pairing
    match /users/{userId} {
      allow read: if isSignedIn();
      allow create: if isSignedIn() && isOwner(userId);

      // Allow updates to own document OR when adding partnerId/coupleId (for pairing)
      allow update: if isSignedIn() && (
        isOwner(userId) ||
        (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['partnerId', 'coupleId']))
      );

      allow delete: if false; // Don't allow deleting users
    }

    // Invite codes collection
    match /inviteCodes/{codeId} {
      // Anyone authenticated can create an invite code
      allow create: if isSignedIn();

      // Anyone can read invite codes (needed to validate codes)
      allow read: if true;

      // Only the creator can update their own codes
      // Or anyone can update when using a code (marking as used)
      allow update: if isSignedIn();

      // Don't allow deleting codes
      allow delete: if false;
    }

    // Couples collection
    match /couples/{coupleId} {
      // Anyone authenticated can create a couple
      allow create: if isSignedIn();

      // Only members of the couple can read
      allow read: if isSignedIn() && (
        resource.data.user1Id == request.auth.uid ||
        resource.data.user2Id == request.auth.uid
      );

      // Only members of the couple can update
      allow update: if isSignedIn() && (
        resource.data.user1Id == request.auth.uid ||
        resource.data.user2Id == request.auth.uid
      );

      // Don't allow deleting couples
      allow delete: if false;
    }

    // Expenses collection
    match /expenses/{expenseId} {
      // Anyone authenticated can create expenses
      // We validate coupleId on the client side
      allow create: if isSignedIn();

      // For reading: check if expense belongs to user's couple
      // Use request.resource for writes, resource for reads
      allow read: if isSignedIn() && (
        // Check if the expense's coupleId matches user's couple membership
        exists(/databases/$(database)/documents/couples/$(resource.data.coupleId)) &&
        (
          get(/databases/$(database)/documents/couples/$(resource.data.coupleId)).data.user1Id == request.auth.uid ||
          get(/databases/$(database)/documents/couples/$(resource.data.coupleId)).data.user2Id == request.auth.uid
        )
      );

      // For listing (queries): allow if user has a couple
      // This is a workaround since we can't access resource.data in queries
      allow list: if isSignedIn() &&
        exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.coupleId != null;

      // Anyone in the couple can update expenses
      // Allow updating settlement fields (settledAt, settledBySettlementId)
      allow update: if isSignedIn() &&
        exists(/databases/$(database)/documents/couples/$(resource.data.coupleId)) &&
        (
          get(/databases/$(database)/documents/couples/$(resource.data.coupleId)).data.user1Id == request.auth.uid ||
          get(/databases/$(database)/documents/couples/$(resource.data.coupleId)).data.user2Id == request.auth.uid
        ) && (
          // Allow updating any fields if user created the expense
          resource.data.paidBy == request.auth.uid ||
          // Allow only updating settlement fields for all users in couple
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['settledAt', 'settledBySettlementId'])
        );

      // Anyone in the couple can delete expenses
      allow delete: if isSignedIn() &&
        exists(/databases/$(database)/documents/couples/$(resource.data.coupleId)) &&
        (
          get(/databases/$(database)/documents/couples/$(resource.data.coupleId)).data.user1Id == request.auth.uid ||
          get(/databases/$(database)/documents/couples/$(resource.data.coupleId)).data.user2Id == request.auth.uid
        );
    }

    // Settlements collection
    match /settlements/{settlementId} {
      // Users can create settlements ONLY for their own couple
      // Validates: user has couple, settlement is for their couple, user is member of couple
      allow create: if isSignedIn() &&
        exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.coupleId != null &&
        request.resource.data.coupleId == get(/databases/$(database)/documents/users/$(request.auth.uid)).data.coupleId &&
        (request.resource.data.user1Id == request.auth.uid || request.resource.data.user2Id == request.auth.uid) &&
        request.resource.data.amount > 0;

      // For reading individual settlements
      allow read: if isSignedIn() && (
        resource.data.user1Id == request.auth.uid ||
        resource.data.user2Id == request.auth.uid
      );

      // For listing settlements (queries): allow if user has a couple
      allow list: if isSignedIn() &&
        exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.coupleId != null;

      // Don't allow updating or deleting settlements (immutable audit trail)
      allow update, delete: if false;
    }
  }
}
